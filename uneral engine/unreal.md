# Unreal Engine Notes

# Project Structure 

Unreal Engine organizes C++ projects into specific folders and files:

Source/: Contains your C++ source code.
YourProjectName.Build.cs: Build rules for your project.
YourProjectName.h and YourProjectName.cpp: Main game module files.
Config/: Configuration files for your project.
Content/: Contains assets (e.g., Blueprints, textures, models).


# Gameplay Classes

Every gameplay class in Unreal Engine consists of a class header file (.h) and a class source file (.cpp).

## Class Headers

Gameplay classes in Unreal Engine generally have separate and unique class header files. These files are usually named to match the class being defined within, minus the A or U prefix, and using the .h file extension. So, the class header file for the AActor class is named Actor.h. Although Epic code follows these guidelines, no formal relationship between class name and source file name exists in the current engine.


# UCLASS Macro

The UCLASS macro gives the UObject a reference to a UCLASS that describes its Unreal-based type. Each UCLASS maintains one Object called the Class Default Object(CDO). The CDO is essentially a default 'template' Object, generated by the class constructor and unmodified thereafter.

Both the UCLASS and the CDO can be retrieved for a given Object instance, although they should generally be considered read-only. The UCLASS for an Object instance can be accessed at any time using the GetClass() function.

A UCLASS contains a set of properties and functions that define the class. These are normal C++ functions and variables available to standard C++ code, but tagged with Unreal Engine-specific metadata that controls how they behave within the Object system. For more details about the tagging syntax


# UObject

UObjects can have member variables (known as properties) or functions of any type. However, for the Unreal Engine to recognize and manipulate those variables or functions, they must be marked with special macros and must conform to certain type standards.

# Updating Objects

Actors and ActorComponents have their Tick functions called automatically when registered to do so, however, UObjects do not possess any built-in update ability. When it is necessary for your project, this can be added by inheriting from the FTickableGameObject class using the inherits class specifier. They can then implement the Tick() function, which will be called each frame by the engine.

# Destroying Objects

Object destruction is handled automatically by the garbage collection system when an Object is no longer referenced. This means that no UPROPERTY pointers, engine containers, TStrongObjectPtr, or class instances should have any strong references to them.

When the garbage collector runs, unreferenced Objects found are removed from memory. In addition, the function MarkPendingKill() can be called directly on an Object. This function sets all pointers to the Object to NULL and removes the Object from global searches. The Object is fully deleted on the next garbage collection pass.

Object->MarkPendingKill() has been replaced with Obj->MarkAsGarbage(). This new function is now only for tracking stale objects, If gc.PendingKillEnabled=true then objects marked as PendingKill will be automatically nulled and destroyed by Garbage Collector.
Strong references keep UObjects alive. If you don't want these references to keep the UObject alive, then those references should convert to using weak pointers, or be a normal pointer that is manually cleared by a programmer (if performance is critical.)


# Container in Unnreal Engine

# TArray

TArray is the most common container class within Unreal Engine. It is fast, memory efficient, and safe. TArray types are defined by two properties: Element type, and an optional allocator.

The element type is the type of the objects that will be stored in the array. TArray is what is called a homogenous container, meaning that all of its elements are strictly the same type; you cannot store elements of different types in a single TArray.

TArray is a value type, meaning that it should be treated similarly as any other built-in type, like int32 or float. It is not designed to be extended, and creating or destroying TArray instances with new and delete is not a recommended practice. The elements are also value types, and the array owns them. Destruction of a TArray will result in the destruction of any elements it still contains. Creating a TArray variable from another will copy its elements into the new variable; there is no shared state.

